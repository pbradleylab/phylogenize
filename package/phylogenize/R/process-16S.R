
#--- Process 16S data---#

#' Prepare input file for alignment
#'
#' \code{prepare.vsearch.input} outputs a FASTA file of the sequences in the
#' input 16S data for analysis using vsearch or vsearch.
#'
#' Some particularly relevant global options are:
#' \describe{
#'   \item{vsearch_infile}{String. File name of the sequences written to disk
#'   and then read into vsearch/vsearch.}
#' }
#'
#' @param mtx A presence/absence or abundance matrix, with row names equal to
#'   amplicon sequence variant DNA sequences.
#' @export
prepare.vsearch.input <- function(mtx, ...) {
    opts <- clone_and_merge(PZ_OPTIONS, ...)
    binary = basename(opts('vsearch_dir'))
    check.dna <- is.dna(rownames(mtx))
    if (!(all(check.dna))) {
        pz.error(paste0(
            "Rownames in 16S data must correspond to the actual sequences of ", 
            "denoised amplicon sequence variants, but some rownames contained ",
            "invalid characters ",
            "(e.g. ", rownames(mtx)[which(!check.dna)[1]], ")."))
    }
    asvnames = paste0("Row", (1:nrow(mtx)))
    asvs = rownames(mtx)
    if (binary %in% c("vsearch")) {
        pz.message("Assuming aligner CAN do reverse complement by itself...")
    } else {
        pz.message("Assuming aligner CANNOT do reverse complement by itself...")
        asvnames = c(asvnames, asvnames)
        revcomp = function(x) seqinr::c2s(rev(seqinr::comp(seqinr::s2c(x))))
        asvs = c(asvs, vapply(asvs, revcomp, ""))
    }
    seqinr::write.fasta(as.list(asvs),
                        asvnames,
                        file.out=opts('vsearch_infile'),
                        nbchar=99999,
                        as.string=TRUE)
    return(TRUE)
}

#' Run vsearch analysis on a FASTA file of sequences.
#'
#' \code{run.vsearch} runs, by default, the optimal sequence aligner vsearch
#' (doi.org/10.5281/zenodo.806850) on a FASTA file, typically one generated by
#' \code{prepare.vsearch.input}. By changing the \code{vsearch_dir} option, the
#' aligner vsearch can also be used. If the provided binary name is
#' not"vsearch", \emph{phylogenize} will assume an old version of vsearch is
#' being called that doesn't have the ability to search both strands.
#'
#' Some particularly relevant global options are:
#' \describe{
#'   \item{vsearch_infile}{String. File name of the sequences to be read into
#' vsearch.}
#'   \item{vsearch_outfile}{String. File name where vsearch writes output
#'   which is then read back into \emph{phylogenize}.}
#'   \item{vsearch_dir}{String. Path where the binary of vsearch is found.}
#'   \item{vsearch_cutoff}{Float. Between 0.95 and 1.00; percent identity
#'   minimum for alignment results.}
#'   \item{vsearch_16sfile}{String. Path to the 16S FASTA database that maps
#'   back to MIDAS species.}
#'   \item{data_dir}{String. Path to directory containing the data files
#' required to perform a \emph{phylogenize} analysis. }
#' }
#'
#' @return Returns TRUE unless an error is thrown.
#' @export run.vsearch
run.vsearch <- function(...) {
    opts <- clone_and_merge(PZ_OPTIONS, ...)
    binary = basename(opts('vsearch_dir'))
    pid = opts('vsearch_cutoff')
    if (binary %in% c("vsearch")) {
        vsearch_args = c("--db",
                         file.path(opts('data_dir'),
                                   opts('vsearch_16sfile')),
                         "--usearch_global",
                         opts('vsearch_infile'),
                         "--strand both",
                         "--id",
                         pid,
                         "--blast6out",
                         opts('vsearch_outfile'))
    } else if (binary == "vsearch") {
        vsearch_args = c("--usearch_global",
                         opts('vsearch_infile'),
                         "--db",
                         file.path(opts('data_dir'), opts('vsearch_16sfile')),
                         "--strand both",
                         "--blast6out",
                         opts('vsearch_outfile'),
                         "--id",
                         pid)
    } else {
        pz.warning(paste0("Aligner not recognized, calling as old version of ",
                          "vsearch that does not support reverse complements"))
        vsearch_args = c("--db",
                         file.path(opts('data_dir'),
                                   opts('vsearch_16sfile')),
                         "--usearch_global",
                         opts('vsearch_infile'),
                         "--id",
                         pid,
                         "--blast6out",
                         opts('vsearch_outfile'))
        
    }
    pz.message(paste0("Calling aligner ", binary, " with arguments: ",
                      paste(vsearch_args, sep=" ", collapse=" ")))
    r <- system2(opts('vsearch_dir'),
                 args = vsearch_args)
    if (r != 0) {
        pz.error(paste0("Aligner failed with error code ", r))
    }
    return(TRUE)
}

#' Read in results from vsearch.
#'
#' \code{get.vsearch.results} reads and parses the output of vsearch to get the
#' best-hit MIDAS species identifier for any 16S hit. Note that the reference
#' 16S FASTA database file must describe entries in the format: ">gene;;
#' species_or_genus_ID;;MIDAS_ID". Only MIDAS_ID is used so the contents of
#' "gene" and "species_or_genus_ID" can be arbitrary.
#'
#' Some particularly relevant global options are:
#' \describe{
#'   \item{vsearch_outfile}{String. File name where vsearch writes output
#'   which is then read back into \emph{phylogenize}.}
#' }
#'
#' @return List containing a vector of hits, a vector of MIDAS ID targets, and a
#'     data frame of the assignments as they came out of vsearch.
#' @export
get.vsearch.results <- function(...) {
    opts <- clone_and_merge(PZ_OPTIONS, ...)
    # map to MIDAS IDs using vsearch
    assignments <- data.frame(
        readr::read_tsv(opts('vsearch_outfile')))
    row.hits <- as.numeric(gsub("Row", "", assignments[, 1]))
    row.targets <- sapply(assignments[, 2],
                          function(x) strsplit(x, ";;")[[1]][3])
    return(list(hits=row.hits, targets=row.targets, assn=assignments))
}

#' Sum non-unique rows after vsearch mapping.
#'
#' \code{sum.nonunique.vsearch} takes vsearch results and an abundance or
#' presence/absence matrix, drops any rows that mapped to multiple MIDAS IDs
#' (i.e. that couldn't confidently be assigned to a MIDAS species),
#' then sums any rows that mapped to the same MIDAS ID.
#'
#' Some particularly relevant global options are:
#' \describe{
#'   \item{out_dir}{String. Path to output directory. Default: "output"}
#'   \item{data_dir}{String. Path to directory containing the data files
#'   required to perform a \emph{phylogenize} analysis. Default: on package
#'   load, this default is set to the result of \code{system.file("extdata",
#'   package="phylogenize")}.}
#' }
#'
#' @param vsearch A list obtained by running \code{get.vsearch.results}.
#' @param mtx A presence/absence or abundance matrix, with row names equal to
#'     amplicon sequence variant DNA sequences.
#' @return A new matrix with MIDAS IDs as rows.
#' @export sum.nonunique.vsearch
sum.nonunique.vsearch <- function(vsearch, mtx, ...) {
    opts <- clone_and_merge(PZ_OPTIONS, ...)
    uniq.hits <- which(count.each(vsearch$hits) < 2)
    rh <- vsearch$hits[uniq.hits]
    rt <- vsearch$targets[uniq.hits]
    subset.abd <- mtx[rh, , drop=FALSE]
    urt <- unique(rt)
    summed.uniq <- sapply(urt, function(r) {
        w <- which(rt == r)
        apply(subset.abd[w, , drop=FALSE], 2, sum)
    }) %>% t
    rownames(summed.uniq) <- urt
    summed.uniq
}

